needs dissect'

variable qdepth

: resolveName  ( a-a )
  dup @ xt->d dup [ d->name ] [ drop dup putn " do" ] if puts space 1+ ;

: dumpString  ( a-a )
  '" putc [ repeat @+ 0; putc again ] do '" putc space ;

: string?  ( a-af )
  dup @ 1- @ 0 = ;

: decompile  ( a-a )
  dup @
  [ 0 = ] [ 1+ ] whend
  [ 1 = ] [ 1+ dup @ putn space 1+ ] whend
  [ 8 = ] [ 1+ string? [ 1+ dumpString 2 + ] [ dup @ "jump: %d " puts 1+ ] if ] whend
  [ 9 = ] [ 1+ @qdepth [ "] " qdepth -- ] [ "; " ] if puts ] whend
  [ &quote  = ] [ qdepth ++ 2 + "[ " puts ] whend
  [ 0 31 within not ] [ resolveName ] whend
  [ &quote <> ] [ ^dissect'decompile ^strings'trimRight "%s " puts ] whend
  drop ;

: see
  0 !qdepth
  ' cr [ decompile @qdepth [ decompile -1 ] [ dup 1- ^dissect'endOfWord? not ] if ] while drop ;

doc{
Known Limitations
-----------------
*  no support for recognizing repeat/again pairs
*  string identification could be more robust
*  literals could be resolved to names, or ASCII characters
}doc

: hello [ 1 2 + [ "hello" puts ] do ] do ;
see hello
: harm [ 1 [ 2 ] ] ;
see harm

