*This is a random collection of notes and snippits related to things I'm working on*

== Images for Embedded Use ==

A standard image is 32-bit, and assumes a big memory area (a typical VM will provide
around 1,000,000 cells). Assume that a standard image consumes around 10k cells. So
just to have everything in memory needs 40 KiB. In addition to this, we have some
necessary buffers for temporary strings and such. So add another 8 - 10k cells. On
a 32-bit system, you need at least 80 KiB of RAM to comfortably hold the image and
buffers.

What we can do is:

1) Use 16 bits per cell if possible
2) Reduce the buffers

Most of the buffers are for strings. A standard image has 512 cells per string. With
12 temporary buffers, this is 6k cells. There's another couple of buffers used for
strings as well, bringing us to 8-10k. On an embedded system, we can cut the size of
the strings down a lot:

[ 128 ] is STRING-LENGTH

This cuts the memory consumption down to around 2 - 3k cells. Reducing the number of
temporary buffers can lead to even more savings:

[ 4 ] is STRING-BUFFERS

This would reduce memory down to approx 1.5k cells. after running these sequences,
save the image to test out the memory reductions.


== Image Naming ==

retroImage

Followed by an optional suffix referring to bits per cell:

  16  for 16-bit
  64  for 64-bit

And a final optional suffix for endian:

  BE  for big endian

